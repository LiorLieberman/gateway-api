# GEP-2162: Supported features in GatewayClass Status

* Issue: [#2162](https://github.com/kubernetes-sigs/gateway-api/issues/2162)
* Status: Provisional

## TLDR

This GEP proposes to enhance the [GatewayClassStatus](https://github.com/kubernetes-sigs/gateway-api/blob/f2cd9bb92b4ff392416c40d6148ff7f76b30e649/apis/v1beta1/gatewayclass_types.go#L185) to include a list of Gateway API features supported by the installed GatewayClass. 

## Goals

* Improve UX by enabling users to easily see what features the implementation (GatewayClass) support.

* Standardize features and conformance tests names.

* Automatically run conformance tests based on the supported features populated in GatewayClass status.

* Provide foundation for tools to block or warn when unsupported features are used.


## Non-Goals

* Validate correctness of supported features published by the implementation. Meaning we don't intend to verify whether the supported features reported by the implementation are indeed supported.

## Introduction

The current [GatewayClassStatus](https://github.com/kubernetes-sigs/gateway-api/blob/f2cd9bb92b4ff392416c40d6148ff7f76b30e649/apis/v1beta1/gatewayclass_types.go#L185 is only used to store conditions the controller publishes.

Partnered with the [Conformance Profiles](https://github.com/kubernetes-sigs/gateway-api/blob/main/geps/gep-1709.md) work, we want to:

1. Improve UX by enabling users to easily see what features the implementation(GatewayClass) support.
1. Standardize features and conformance tests names.
1. Automatically run conformance tests based on the supported features populated in GatewayClass status.
1. Potentially build tooling to block or warn when unsupported features are used (more under [Future Work](#future-work)).

This doc proposes to enhance the GatewayClassStatus API so implementations could publish a list of features they support/don't support.

Implementations **must** publish the supported features before Accepting the GatewayClass, or in the same operation.

Implementations are free to decide how they manage this information - common approach could be to maintain static lists of supported features or using predefined sets.

Note: implementations must keep the published list sorted.

## API

This GEP proposes API changes describes as follow:

* Update the `GatewayClassStatus` struct to include a string-represented list of `SupportedFeatures`.


```go
// GatewayClassStatus is the current status for the GatewayClass.
type GatewayClassStatus struct {
    // Conditions is the current status from the controller for
    // this GatewayClass.
    //
    // Controllers should prefer to publish conditions using values
    // of GatewayClassConditionType for the type of each Condition.
    //
    // +optional
    // +listType=map
    // +listMapKey=type
    // +kubebuilder:validation:MaxItems=8
    Conditions []metav1.Condition `json:"conditions,omitempty"`

    // SupportedFeatures is the features the GatewayClass support.
    // <gateway:experimental>
    // +kubebuilder:validation:MaxItems=64
    SupportedFeatures []string `json:"supportedFeatures,omitempty"`
}
```

## Understanding SupportedFeatures field

Its important to define how we read the list of `SupportedFeatures` we report.

We have no support features for core features. If an implementation reports a route name e.g `HTTPRoute` as a supportedFeature it means it supports all its core features.
In other words, supporting the route's core features is a requirement for the implementation to say that it supports the route.

For Extended/Implementation-specific features we have the supported features names.

An example of a GatewayClass Status with the SupportedFeatures reported would look like:

```yaml
apiVersion: gateway.networking.k8s.io/v1beta1
kind: GatewayClass
...
status:
  conditions:
  - lastTransitionTime: "2022-11-16T10:33:06Z"
    message: Handled by XXX controller
    observedGeneration: 1
    reason: Accepted
    status: "True"
    type: Accepted
  supportedFeatures:
    - HTTPRoute
    - HTTPRouteHostRewrite
    - HTTPRoutePortRedirect
    - HTTPRouteQueryParamMatching

```
## Standardize features and conformance tests names

Before we add the supported features into our API, it is necessary to establish standardized naming and formatting conventions.

### Formatting Proposal

#### Feature Names

Every feature should:

1. Start with the resource name. i.e HTTPRouteXXX
2. Follow the PascalCase convention. Note that the resource name in the string should come as is and not be converted to PascalCase, i.e HTTPRoutePortRedirect and not HttpRoutePortRedirect.
3. Not exceed 128 characters.
4. Contain only letters and numbers

#### Conformance tests names

Conformance tests file names should try to follow the the `pascal-case-name.go` format.
For example for `HTTPRoutePortRedirect` - the test file would be `httproute-port-redirect.go`.

We should treat this requirement as "best effort" because we might have test files that checks combination of features and can't follow the same format.

In any case, the conformance tests file names should be meaningful and easy to understand.


## Followups

Before we make the changes we need to;
1. Change the names of the support features and conformance tests that don't conform with the formatting rules.
1. Move `ReferenceGrant`` to Extended
    * `ReferenceGrant` is not supported by all the implementations now and it will block them from reporting support for core route features.
    <!-- TODO(liorlieberman) find the link of sig-auth work -->
    * The current plan is that `ReferenceGrant` is not going to go GA. sig-auth is working on something thats supposed to replace it ([kubernetes/enhancements#3766](https://github.com/kubernetes/enhancements/issues/3766) for more info).
    * Even if it needs to go GA eventually, it is easier to move from Extended to Core than the other way around.


## Conformance Details

(TBD)

## Alternatives

### Re-using ConformanceProfiles structs

We could use the same structs as we do in conformance profile object, more specifically, the [ProfileReport](https://github.com/kubernetes-sigs/gateway-api/blob/main/conformance/apis/v1alpha1/profilereport.go#LL24C6-L24C19) struct.

Though it would be nice to have only one place to update, these structs seems to include much more data relevant to the conformance report but not for our use case. 

That said, conformance profiles are still at experimental stage, we could explore the option to create a shared struct that will be used both for the conformance reports and for the GatewayClass status.

### Instruct users to read from the future conformance profiles report

The current plan for conformance profiles is to also include centralized reporting. (more info in [gep-1709](https://github.com/kubernetes-sigs/gateway-api/blob/main/geps/gep-1709.md))
We could wait for this to be implemented and instruct users to read from that source to determine what features their installed GatewayClass support.

However, having the supported features published in the GatewayClass Status adds the following values:
* We could build a mechanism or a tool to block or warn when unsupported features are used.
* Users will be able to select the GatewayClass that suits their needs without having to refer to documentation or conformance reports.

This does not cover a future piece of work we want to implement which is to warn/block users from applying a Gateway API object if the installed GWC doesn't support it. (originally suggested in [#1804](https://github.com/kubernetes-sigs/gateway-api/issues/1804)). 


## References

[discussion #2108](https://github.com/kubernetes-sigs/gateway-api/discussions/2108)
[#1804](https://github.com/kubernetes-sigs/gateway-api/issues/1804)

## Future Work

### Research the development of an unsupported feature warning/blocking mechanism
Once the GatewayClass features support are is published into the status we could look into;

1. Using the supported features in the webhook to validate or block attempts to apply manifests with unsupported features.

    * Developing such mechanism looks like it would have to include cross-resource validation. (checking the GatewayClass while trying to apply a Route for example). This comes with a lot of caveats and we will need consider it carefully.

2. Build tooling to check and warn when unsupported features are used.
